; Test the difference between 'let' and 'assign'

(print "=== Test 1: Global variable update with assign ===")
(let counter 0)
(print "Initial counter:" counter)

(fn increment ()
  (assign counter (+ counter 1)))

(increment)
(print "After increment:" counter)

(increment)
(print "After second increment:" counter)

(print "\n=== Test 2: let creates shadow, doesn't update global ===")
(let x 10)
(print "Global x:" x)

(fn try_shadow ()
  (let x 999)
  (print "Inside function, x:" x))

(try_shadow)
(print "After function, global x:" x)

(print "\n=== Test 3: assign updates global from function ===")
(let y 10)
(print "Global y:" y)

(fn update_global ()
  (assign y 999)
  (print "Inside function, y:" y))

(update_global)
(print "After function, global y:" y)

(print "\n=== Test 4: Counter with while loop ===")
(let sum 0)
(let i 1)
(while (<= i 5)
  (assign sum (+ sum i))
  (assign i (+ i 1)))
(print "Sum of 1 to 5:" sum)

(print "\n=== Test 5: Nested function scopes ===")
(let value 1)
(print "Initial value:" value)

(fn outer ()
  (print "Outer sees value:" value)
  (assign value 2)
  (print "Outer changed value to:" value)
  
  (fn inner ()
    (print "Inner sees value:" value)
    (assign value 3)
    (print "Inner changed value to:" value))
  
  (inner)
  (print "After inner, value:" value))

(outer)
(print "After outer, global value:" value)

(print "\n=== Test 6: Error case - assign undefined variable ===")
(print "This should work - let creates new variable:")
(let new_var 42)
(print "new_var:" new_var)

; This will cause an error if uncommented:
; (assign undefined_var 100)
; (print "This won't print")
